# The Game Controller and View

INDEX

We want to be able to carry out the full RESTful actions on game:

1. List - the index action
2. Create - the new > create actions
3. Edit - the edit > update actions
4. Show - the show action
5. Destroy - the destroy action

So we're going to generate the controller, set the controller up as a RESTful resource in our routes, write the functional tests then make them all pass.



## Generate the controller
We'll tell the generator to all of the RESTful actions for us.

~~~console
rails generate controller games index new create update edit show destroy

create  app/controllers/games_controller.rb
      route  get "games/destroy"
      route  get "games/show"
      route  get "games/edit"
      route  get "games/update"
      route  get "games/create"
      route  get "games/new"
      route  get "games/index"
     invoke  erb
     create    app/views/games
     create    app/views/games/index.html.erb
     create    app/views/games/new.html.erb
     create    app/views/games/create.html.erb
     create    app/views/games/update.html.erb
     create    app/views/games/edit.html.erb
     create    app/views/games/show.html.erb
     create    app/views/games/destroy.html.erb
     invoke  rspec
     create    spec/controllers/games_controller_spec.rb
     create    spec/views/games
     create    spec/views/games/index.html.erb_spec.rb
     create    spec/views/games/new.html.erb_spec.rb
     create    spec/views/games/create.html.erb_spec.rb
     create    spec/views/games/update.html.erb_spec.rb
     create    spec/views/games/edit.html.erb_spec.rb
     create    spec/views/games/show.html.erb_spec.rb
     create    spec/views/games/destroy.html.erb_spec.rb
     invoke  helper
     create    app/helpers/games_helper.rb
     invoke    rspec
     create      spec/helpers/games_helper_spec.rb
     invoke  assets
     invoke    coffee
     create      app/assets/javascripts/games.js.coffee
     invoke    scss
     create      app/assets/stylesheets/games.css.scss
~~~

Let's create games as a RESTful resource in `config/routes.rb` by removing:

~~~ruby
get "games/index"

get "games/new"

get "games/create"

get "games/update"

get "games/edit"

get "games/show"

get "games/destroy"
~~~

and creating games as a resource. Since we're using all of the RESTful actions then we don't need to limit it with `:only =>[]` 

~~~ruby
Stinkytrainers::Application.routes.draw do
  
  
  devise_for :users

  resources :sports, :only => [:index, :new, :create, :destroy]

  resources :dashboard, :only => [:index] 
  
  resources :games

  root :to => 'home#index'

end
~~~

Take a look at the routes we've created

~~~console 
bundle exec rake routes

 new_user_session GET    /users/sign_in(.:format)                  devise/sessions#new
            user_session POST   /users/sign_in(.:format)                  devise/sessions#create
    destroy_user_session DELETE /users/sign_out(.:format)                 devise/sessions#destroy
           user_password POST   /users/password(.:format)                 devise/passwords#create
       new_user_password GET    /users/password/new(.:format)             devise/passwords#new
      edit_user_password GET    /users/password/edit(.:format)            devise/passwords#edit
                         PUT    /users/password(.:format)                 devise/passwords#update
cancel_user_registration GET    /users/cancel(.:format)                   devise/registrations#cancel
       user_registration POST   /users(.:format)                          devise/registrations#create
   new_user_registration GET    /users/sign_up(.:format)                  devise/registrations#new
  edit_user_registration GET    /users/edit(.:format)                     devise/registrations#edit
                         PUT    /users(.:format)                          devise/registrations#update
                         DELETE /users(.:format)                          devise/registrations#destroy
                  sports GET    /sports(.:format)                         sports#index
                         POST   /sports(.:format)                         sports#create
               new_sport GET    /sports/new(.:format)                     sports#new
                   sport DELETE /sports/:id(.:format)                     sports#destroy
         dashboard_index GET    /dashboard(.:format)                      dashboard#index
                   games GET    /games(.:format)                          games#index
                         POST   /games(.:format)                          games#create
                new_game GET    /games/new(.:format)                      games#new
               edit_game GET    /games/:id/edit(.:format)                 games#edit
                    game GET    /games/:id(.:format)                      games#show
                         PUT    /games/:id(.:format)                      games#update
                         DELETE /games/:id(.:format)                      games#destroy
                    root        /                                         home#index
~~~

You can see we now have games routes matching each of our actions. As a quick reminder of RESTful routes let's review the routes we've created. I've assumed we already have a game with the id 179:

<table>
	<tr>
		<th>url</th>
		<th>action</th>
	</tr>
	<tr>
		<td>GET /games</td>
		<td>games#index</td>
	</tr>
	<tr>
		<td>POST /games</td>
		<td>games#create</td>
	</tr>
	<tr>
		<td>GET /games/new</td>
		<td>games#new</td>
	</tr>
	<tr>
		<td>GET /games/179/edit</td>
		<td>games#edit with params[:id] = 179</td>
	</tr>
	<tr>
		<td>GET /games/179</td>
		<td>games#show with params[:id] = 179</td>
	</tr>
	<tr>
		<td>PUT /games/179</td>
		<td>games#update with params[:id] = 179</td>
	</tr>
	<tr>
		<td>DELETE /games/179</td>
		<td>games#destroy with params[:id] = 179</td>
	</tr>
</table>

## Our draft functional tests for the games controller
I'm going to introduce the concept of describe blocks in testing here. They let us group our tests together and each block can have its own setup and teardown code. Don't worry if you're not sure what setup and teardown means all will become apparent.

Before we write our draft tests we must delete the file `spec/constrollers/games_controller_spec.rb` since we're testing views and controllers together as integration tests.

Create the file spec/integration/games/resftful_spec.rb and add the empty draft tests below: 

~~~ruby
require 'spec_helper'

describe 'games' do
  
  describe 'authentication' do
    it 'should redirect users to the sign-in page when they are not signed-in'
  end

  describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user'
    it 'should display a list of the games where the signed-in user is a player'
  end

  describe 'creating games' do
    it 'should create a new game when valid game parameters are provided'
    it 'should redirect users back to the new page with user input when incorrect parameters are provided'
  end


  describe 'editing games' do
    it 'should edit a game and update it when the values are valid'
    it 'should edit a game and return then to the edit page with their edited input when incorrect parameters are provided'
  end

  describe 'showing games' do
    it 'should allow users to view a game'
  end

  describe 'destroying games' do
    it 'should allow users to destroy a game and redirect them back to the index page'
  end
  
end
~~~

## Testing authentication
The test we need to pass is `it 'should redirect users to the sign-in page when they are not signed-in'`

This is very similar to our previous authentication tests. Create the file `spec/integration/games/authentication_spoec.rb` and add this code:

~~~ruby
require 'spec_helper'

describe 'authentication' do
  it 'should require users to sign in when they trying to access sports' do
    user = FactoryGirl.create(:user)

    visit games_path

    page.current_path.should == new_user_session_path

    fill_in('Email', :with => user.email)
    fill_in('Password', :with => user.password)

    click_button('Sign in')

    page.current_path.should == games_path
  end
end
~~~

Run the tests:

~~~ruby
bundle exec rake spec
~~~

You should see one failure because we haven't secured the games_controller yet. So we'll do that now by adding the Devise `authenticate_user!`

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
  end

  def new
  end

  def create
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

Run the tests again and it should all pass

~~~ruby
bundle exec rake spec
~~~

## Testing the index action
Our previous sports controller index action was quite simple, all we wanted to do is list all sports. This one is a little more difficult as we want to list two things:

~~~ruby
describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user'
    it 'should display a list of the games where the signed-in user is a player'
end
~~~

### Make our games Factory more useful

Before we start writing tests, Games require owners and sports so our integration tests are going to be using FactoryGirl to create these objects quite frequently.

Our current games factory `spec/factories/games.rb` looks something like this

~~~ruby
FactoryGirl.define do
  factory :game do
    location "MyString"
    at "2012-09-09 10:00:00"
    sport { FactoryGirl.create(:sport) }
    owner { FactoryGirl.create(:user) }
  end
end
~~~ 

So in our tests the :location and :at fields always have the same values which isn't really realistic or helpful. Update it so that, like email in the user factory and name in the sport factory, locations and times are always different. 

~~~ruby
FactoryGirl.define do
  factory :game do
    location { generate(:location) } 
    at { generate(:at) }
    sport { FactoryGirl.create(:sport) }
    owner { FactoryGirl.create(:user) }          
  end
  
  sequence :location do |n|
    "location#{n}"
  end

  sequence :at do |n|
    Time.now + (n * 3600 * 24)
  end
end
~~~

### Make our external player Factory more useful
Lets make the email a sequence like user. We don't have to define the sequence as we can just use the one from user. In spec/factories/external_players.rb

~~~ruby
FactoryGirl.define do
  factory :external_player do
    email{ generate(:email) }
  end
end
~~~

### it 'should display a list of the games owned by the signed-in user'

So now let's code the first of our two tests.

First let's create a before(:each) block inside the `describe games` block. This will run before each test giving us a signed-in user `@user` so we don't have to keep writing the same login code over and over again. Again because we assign user to the instance variable `@user` and not just `user` it's available throughout the test. 

Write a test to: 

1. Create our signed-in user
1. Create another user that isn't the signed-in user
1. Create three games, two owned by the signed-in user and one owned by the user not signed-in
1. Ensure that the games we added to the user appears in the 'owned\_games' table on index page
1. Ensure that the game we didn't add to the signed-in user **doesn't appear** in the 'owned\_games' table on  the index page

Note that we check for the existence of the games inside these within blocks

~~~ruby
within("table#owned_games") do
  within("tr[@data-row='game_#{game1.id}']") do
  end
end
~~~

Which basically means the test is more than requiring the games to appear on the page, it's requiring the games to appear within a table with id my\_games and a table row with the data-row attribute data-row='game_x' where x is the id of the game in that row.

We could also have used more specific XPath and css attributes to specify where the games appear but then we'd have to keep fixing our tests each time the page design was altered. This approach feels like a reasonably pragmatic balance between not caring where the games appear and being very specific.

~~~ruby  
require 'spec_helper'

describe 'games' do
  
  before :each do
    @user = FactoryGirl.create(:user)
	  
	visit new_user_session_path
	  
	fill_in('Email', :with => @user.email)
    fill_in('Password', :with => @user.password)

    click_button('Sign in')
  end
  
  
  describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user' do
        
    	other_user = FactoryGirl.create(:user)

	    game1 = FactoryGirl.create(:game, :owner => @user)
	    game2 = FactoryGirl.create(:game, :owner => @user)
	    game3 = FactoryGirl.create(:game, :owner => other_user)
    
	    visit games_path
  
	    within("table#owned_games") do
      
	      @user.owned_games.each do |game|
	        within("tr[@data-row='game_#{game.id}']") do
	          page.should have_content(game.location)
	          page.should have_content(game.sport.name)
	          page.should have_content(game.at)
	        end
	      end
      
	      other_user_game = other_user.owned_games.first
	      #page.save_and_show_page
	      page.should_not have_content(other_user_game.location)
	      page.should_not have_content(other_user_game.sport.name)
	      page.should_not have_content(other_user_game.at)
    
	    end
	
	end
	
	it 'should display a list of the games where the signed-in user is a player'
	
  end

  describe 'creating games' do
    it 'should create a new game when valid game parameters are provided with the current user selected as a player'
    it 'should redirect users back to the new page with user input when incorrect parameters are provided'
  end


  describe 'editing games' do
    it 'should edit a game and update it when the values are valid'
    it 'should edit a game and return then to the edit page with their edited input when incorrect parameters are provided'
  end

  describe 'showing games' do
    it 'should allow users to view a game'
  end

  describe 'destroying games' do
    it 'should allow users to destroy a game and redirect them back to the index page'
  end
  
end
~~~

run the tests...

~~~console
bundle exec rake spec
~~~

and it should fail because we haven't coded the controller or the view we're testing.

Let's start with the games controller `app/controllers/games_controller.rb`. It couldn't be simpler. In our previous sports controller we wanted all sports to be listed so we coded

~~~ruby
def index
  @sports = Sport.all
end
~~~

but now we want to list the games of the logged-in user (we can be sure we have a logged-in user because our previous spec required that). All we need do assign the games of the current user to variable @games which is passed to our view. Note that only instance (or '@') variables get passed on to the view. Variables that aren't prefixed '@' are local to the method only. 

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
    @owned_games = current_user.owned_games
  end

  def new
  end

  def create
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

You can try running the tests but they should still fail as we haven't coded the view. Let's do that now:

in `app/views/games/index.html.erb`

~~~ruby
<h1>Games#index</h1>

<h2>Game I have created</h2>
<table id="owned_games">
	<% @owned_games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>
~~~

Note that we use the `@owned_games` variable from our controller and insert the game id into the data-row attribute of the table.

Our test should now pass:

~~~console
bundle exec rake spec
~~~

### it 'should display a list of the games where the signed-in user is a player'
Now let's add the test that checks the list of games the signed-in user is playing in.

In this test we will

1. Create three games, two owned by the signed-in user and a third by another user
1. Add the signed-in user to one of the two games he/she created and add the signed-in user to the game created by the other user.
1. Test that the table "games" has the two games in which the signed-in user is a player - that's one of his games and one of the other user's games.
1. Test that the table "games" doesn't have the game in which the signed-in user isn't a player even though that's a game he created.

Add this code to the second of our two index page tests:

~~~ruby
it 'should display a list of the games the signed-in user is playing in' do

	game1 = FactoryGirl.create(:game, :owner => @user)
	game2 = FactoryGirl.create(:game, :owner => @user)
	game3 = FactoryGirl.create(:game, :owner => FactoryGirl.create(:user))
  
	game1.players << @user
	game3.players << @user

	visit games_path

	within("table#games") do
   
	  within("tr[@data-row='game_#{game1.id}']") do
	    page.should have_content(game1.location)
	    page.should have_content(game1.sport.name)
	    page.should have_content(game1.at)
	  end
  
	  within("tr[@data-row='game_#{game3.id}']") do
	    page.should have_content(game3.location)
	    page.should have_content(game3.sport.name)
	    page.should have_content(game3.at)
	  end
  
	  game_user_created = @user.games.last
  
	  page.save_and_open_page
  
	  page.should_not have_content(game2.location)
	  page.should_not have_content(game2.sport.name)
	  page.should_not have_content(game2.at)

	end
	
end
~~~

Run the tests to see it failing (remember we haven't coded the controller or view yet)

~~~console
bundle exec rake spec


1) games listing games should display a list of the games the signed-in user is playing in
    Failure/Error: within("table#games") do
    Capybara::ElementNotFound:
      Unable to find css "table#games"
    # (eval):2:in `find'
    # ./spec/integration/games/restful_spec.rb:57:in `block (3 levels) in <top (required)>'
	
~~~

Let's add a variable to our `app/controllers/games\_controller.rb` index action to reference the games our signed-in user is playing in.

~~~ruby
def index
 @owned_games = current_user.owned_games
 @games = current_user.games
end
~~~

and add the games table to the view app/views/games/index.html.erb

~~~ruby
<h1>Games#index</h1>

<h2>Games I have created</h2>
<table id="owned_games">
	<% @owned_games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>

<h2>Games I am playing</h2>
<table id="games">
	<% @games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>
~~~

The tests should now pass.

## Creating Games
If a user provides the correct information to create a new game we want to redirect them to the game's 'show' page but if the information provided is invalid we return them to the 'new' page where they can correct the information.

~~~ruby
describe 'creating games' do
    it 'should create a new game when valid game parameters are provided and redirect'
    it 'should return users back to the new page with user input when incorrect parameters are provided'
end
~~~

### it 'should create a new game when valid game parameters are provided and redirect to the show page'
To do this the spec must

1. Journey to the new page by clicking a 'Create Game' link from the index page.
1. Select a sport for our game from a drop-down.
1. Complete a text box for `game.location`
1. Complete a rails **date_time_select** for `game.at`

A Rails date time select is a helper method that provides us with 5 drops down selects for year, month, day, hour and minute. In our case the selects for our `game.at` attribute will be called:

game[at(1i)]
game[at(2i)]
game[at(3i)]
game[at(4i)]
game[at(5i)]

ActiveRecord will automagically reassemble these five components back into a time for us.

~~~ruby
it 'should create a new game when valid game parameters are provided and redirect to the show page' do

	sport = FactoryGirl.create(:sport)

	visit games_path

	click_link('Create Game')

	fill_in("Location", :with => 'Wimbledon')
	select(sport.name, :from => "Sport")

	time = Time.now + 3600 #make it an hour from now

	select(time.year.to_s, :from => 'game[at(1i)]')
	select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	select(time.day.to_s, :from => 'game[at(3i)]')
	select(time.hour.to_s, :from => 'game[at(4i)]')
	select(time.min.to_s, :from => 'game[at(5i)]')

	expect{
	 click_button('Create Game')
	}.to change{Game.count}.by(1)

	page.current_path.should == game_path(Game.last)

end
~~~

I'm pretty certain that we'll be using the exact same form in 'edit' and 'new' so we'll create the form as a partial. Create the file `app/views/games/_form.html.erb` and include this in our 'new' view `app/views/games/hew.html.erb`. This will render `_form.html.erb` inside the view `new.html.erb`

~~~ruby
<h1>Games#new</h1>

<%= render 'form' %>
~~~

Let's code the form.

~~~ruby
<%= form_for @game do |f| %>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :sport_id, 'Sport', :class => 'control-label' %>
    <div class='controls'>
      <%= f.select :sport_id, options_from_collection_for_select(Sport.all, :id, :name), {:include_blank => true}, {:class => 'input-xlarge' } %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :location, :class => 'control-label' %>
    <div class='controls'>
      <%= f.text_field :location, :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :at, :class => 'control-label' %>
    <div class='controls'>
      <%= f.datetime_select "at",{}, :class => 'input-small' %>
    </div>
  </div>

  <div class="form-actions">
    <%= f.submit @game.new_record? ? 'Create Game' : 'Update Game', :class => 'btn btn-primary' %>
    <%= link_to 'Back', games_path, :class => 'btn' %>
  </div>

<% end %>
~~~

1. form\_for @game understands that this is a new record. @game.new\_record? == true because @game.id is nil. It creates a POST action rather than a PUT. When we get as far as editing an existing game then @game.new\_record? == false because a game being edited will have an id. In this case form_for will make it a RESTFUL PUT action.
1. `form_for @game do |f|` labels and controls are bound to @game via 'f' e.g. `<%= f.label :location, :class => 'control-label' %>  <%= f.text_field :location, :class => 'input-xlarge' %>`. The :class arguments are simply TwitterBootstrap class names we want to appear in the html.
1. We've bound the :sport_id to the select box 'Sport' so that the parameter game[sport\_id] is submitted. If we'd left it as sport then game[sport]=1 would imply we had a sport that was the number 1 and not a sport object with an id that is 1. 
1. `options_from_collection_for_select(Sport.all, :id, :name)` builds the select drop-down with an option for each sport in `Sport.all` using the sport `sport.id` and `sport.name` as the option value and text. 

That's our form, let's code the new and create action in `app/controllers/games_controller.rb`.

~~~ruby
def new
	@game = Game.new
end

def create
  game = Game.new(params[:game])
  game.owner = current_user
  game.save
  redirect_to game\_path(game)
end
~~~

In `def new` we instantiate an empty game object so that it can be bound to the controls in our _form.html.erb partial. 

In `def create` we instantiate an empty object passing it params[:game]. Params[:game] is a hash containing all of the values submitted by our form that have game[:location], game[:sport_id]. A typical params hash is `{"utf8"=>"✓", "game"=>{"sport_id"=>"1", "location"=>"Wimbledon", "at(1i)"=>"2012", "at(2i)"=>"9", "at(3i)"=>"22", "at(4i)"=>"16", "at(5i)"=>"15"}, "more_players"=>"email", "commit"=>"Create Game", "action"=>"create", "controller"=>"games"}`. Note the keys and values in the `"game" =>` part of the hash.

A game needs an owner and that will always be the current user in our system so we set it.

We save the game and then redirect to the 'show' page for that game. Save would have populated the `game.id` from the database so game\_path(game) would be /games/123 for a game with id 123.

One last thing and this is a little ugly. Remember our form's sport control is bound to :sport\_id and not :sport ? Well, when we come to create our game in the controller it will be updating :sport\_id => 1 which means we have to make :sport\_id attr_accessible as well as sport. If we don't we're going to get one of those `Can't mass-assign protected attributes: sport_id` errors when we save.

~~~ruby
class Game < ActiveRecord::Base
  attr_accessible :at, :location, :sport, :owner, :sport\_id
  
  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
   
  def over?
    Time.now > self.at
  end
  
end
~~~

Let's run the tests, with our form and controller in place they should be passing:

~~~console
bundle exec rake spec
~~~

### it 'should return users back to the new page with user input when incorrect parameters are provided'
This is similar to our previous test but, of course, we do something wrong so that when we submit our form the game is invalid. Let's submit a game that's in the past. We already have a helper method `game.over?` that we know will return true if the game is in the past so let's include that in a validation but ONLY if we're trying to create a new game NOT if we're trying to update something on an existing game.

We will add our own validation method to game. Before we do we'd better go back to our spec/models/game\_spec.rb and write a couple of additional tests for this validation. In `spec/models/game_spec.rb` add the two tests

~~~ruby
it 'should not be valid if the game has not been saved and is in the past' do
  game = Game.new(:at => Time.now - 1000)
  game.stub(:new\_record?).and_return(true)
  game.valid?
  game.errors.get(:at).should include("Cannot create a game in the past")
end

it 'should be valid if the game has been saved and is in the past' do
  game = Game.new(:at => Time.now - 1000)
  game.stub(:new\_record?).and_return(false)
  game.valid?
  game.errors.get(:at).should_not include("Cannot create a game in the past")
end
~~~

run the tests and see the first test fail.

~~~console
bundle exec rake spec
~~~

Note `game.stub(:new\_record?).and_return(false)`. Rather than manipulate test game ids so that we get new_record? to return the expected value we simply stub it out so that, for this one test, the game model returns the exact method we're looking for.

Let's create the validation in `models/game.rb`.

~~~ruby
class Game < ActiveRecord::Base
  attr_accessible :at, :location, :sport, :owner, :sport_id
  
  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
  
  validate :cannot_create_a_game_in_the_past, :on => :create
 
  def over?
    Time.now > self.at
  end
  
  private
  
  def cannot_create_a_game_in_the_past
    return unless self.at
    self.errors.add(:at, 'Cannot create a game in the past') if self.over?
  end
  
end

~~~

We create a private method that checks to see if the game is in the past and call it with `validate :cannot_create_a_game_in_the_past, :on => :create`. The `:on => create` option means that the validation only runs when the object is new - in other words when `game.new_record?` is true. If it is in the past we add the desired error message against our :at attribute. So how do we make sure that the test object returns the desired true or false for `game.new_record?`. We could, for example, create an object, save it with the time at now then wait a few seconds to be sure it'sin the past but that's clumsy. Instead we `game.stub(:new\_record?).and_return(false)` or true. Stub overrides the method `game.new_record?` for that one tests and returns true or false depending on what we specify in `.and_return`. It's simple and explicit.

Note that we had to put in the `return unless self.at` because the comparison would Time.now would fail if at is nil. This doesn't matter as a game with `at` is invalid anyway.

Now we know that we can't create a game in the past let's try and do that to make sure our form returns us back to the new page with the bad data we've entered.

~~~ruby
it 'should redirect users back to the new page with user input when incorrect parameters are provided' do

	sport = FactoryGirl.create(:sport)

	visit games_path

	click_link('Create Game')

	fill_in("Location", :with => 'Wimbledon')
	select(sport.name, :from => "Sport")

	time = Time.now - 3600 #make it an hour in the past

	select(time.year.to_s, :from => 'game[at(1i)]')
	select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	select(time.day.to_s, :from => 'game[at(3i)]')
	select(time.hour.to_s, :from => 'game[at(4i)]')
	select(time.min.to_s, :from => 'game[at(5i)]')

	expect{
	 click_button('Create Game')
	}.to change{Game.count}.by(0)

	page.find_field('Location').value.should have_content('Wimbledon')
	page.find_field('Sport').text.should have_content(sport.name)

	page.find_field('game[at(1i)]').value.should have_content(time.year.to_s)
	page.find_field('game[at(2i)]').text.should have_content(Date::MONTHNAMES[time.month])
	page.find_field('game[at(3i)]').value.should have_content(time.day.to_s)
	page.find_field('game[at(4i)]').value.should have_content(time.hour.to_s)
	page.find_field('game[at(5i)]').value.should have_content(time.min.to_s)
	
end
~~~

So we try to create a game in the past, check that Game.count doesn't change so our attempt to create a game has failed, then check that the rendered page has the `game.sport`, `game.at` and `game.location` data we submitted.

We need to code the controller so that it handles invalid requests so let's update `def create` in our `app/controllers/games_controller.rb` so that it looks like this:

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
    @owned_games = current_user.owned_games
    @games = current_user.games
  end

  def new
    @game = Game.new
    @game.players << current_user
  end

  def create
    @game = Game.new(params[:game])
    @game.owner = current_user
    if @game.save
  		redirect_to game_path(@game)
  	else
  		render :template => 'games/new.html.erb'
  	end
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

Note that we change game to @game so that it can be bound into the 'new' form if the data is invalid. 

~~~console
bundle exec rake spec

Failures:

  1) games creating games should redirect users back to the new page with user input when incorrect parameters are provided
     Failure/Error: page.find_field('Sport').value.should have_content(sport.name)
       expected there to be content "sport7" in ""
     # ./spec/integration/games/restful_spec.rb:134:in `block (3 levels) in <top (required)>'
~~~

Just one problem, it fails. Our drop down for sport hasn't selected the sport we chose `expected there to be content "sport7" in ""` and has displayed the first option which is blank. We can fix this in the form by updating the `options_from_collection_for_select(Sport.all, :id, :name)` so that the form looks like

~~~ruby
<%= form_for @game do |f| %>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :sport_id, 'Sport', :class => 'control-label' %>
    <div class='controls'>
      <%= f.select :sport_id, options_from_collection_for_select(Sport.all, :id, :name, @game.sport.try(:id)), {:include_blank => true}, {:class => 'input-xlarge' } %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :location, :class => 'control-label' %>
    <div class='controls'>
      <%= f.text_field :location, :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :at, :class => 'control-label' %>
    <div class='controls'>
      <%= f.datetime_select "at",{}, :class => 'input-small' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :players, :class => 'control-label' %>
    <div class='controls'>
  		<% current_user.players.each do |player| %>
			<%= check_box_tag :player, player.id, @game.players.include?(player) %> <%= player.email %><br/>
  		<% end %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :players_not_on_stinky_trainers, :class => 'control-label' %>
    <div class='controls'>
  		<% current_user.external_players.each do |player| %>
			<%= check_box_tag :external_player, player.id, @game.external_players.include?(player) %> <%= player.email %><br/>
  		<% end %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :more_players, :class => 'control-label' %>
    <div class='controls'>
      <%= text_field_tag :more_players, 'email', :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="form-actions">
    <%= f.submit @game.new_record? ? 'Create Game' : 'Update Game', :class => 'btn btn-primary' %>
    <%= link_to 'Back', games_path, :class => 'btn' %>
  </div>

<% end %>
~~~

We've added a third argument to `option\_from\_collection\_for\_select`, `@game.sport.try(:id)`. This third argument is the value we'd like the select box to choose as selected (if it exists) but why the `sport.try(:id)` and not just `sport.id` ? Well, on a completely new game in our first test above sport will actually be nil so calling id on nil will raise an error. With `sport.try(:id)` Rails will try to get the value id from sport but return nil, rather than an error, if something goes wrong.

Run the tests and all should be passing

~~~console
bundle exec rake spec
~~~

### What about the players and external_players?

But what about the players ? I know I said that I want to be able to create a game without players but so far we can't add any even if we wanted to. I've left this separate so far. The form we just created was complex enough and adding arrays of players makes it more so. I want to have my form list all of the players and external players that I know in an array of check boxes and this is one of those rare things that Rails doesn't handle seamlessly. As always there are several ways to do something but I've chosen an approach that's reasonably easy to follow.

It's time for some tests. These aren't in my initial set of draft tests. We're agile so let's add these four new tests INSIDE of the `describe 'creating games' do` block as the tests are associated with game creation

~~~ruby

describe 'players' do
  
  it 'should display a list of check_boxes for the current users players in table#players with only the current user selected'

  it 'should display a list of check_boxes for the current users external\_players in table#players all unchecked' 
  	
  it 'should submit a list of the selected players and add them to the game'

  it 'should submit a list of the selected external players and add them to the game'
  
end
~~~

We're going to be building lists of players and external players using the `check_box_tag`. There are two groups of helpers for forms in Rails form\_helpers and form\_tag\_helpers. We've already used form\_helpers, they're useful when we have an activerecord model in our form and they neatly bind the model to the form e.g.

~~~ruby
<% form_for @game %>
	f.text_field :location
	f.select :sport_id
<% end %>
~~~ 

form\_tag\_helpers aren't bound to any objects at all so you would have `check_box_tag` rather than `f.check_box` they help us create html tags. We're going to use them in our form to create a checkbox for every player or external player that our user has shared a game with. How do we get a list of these ? Active record makes this easy for us.

Remember our user has a has\_and\_belongs\_to\_many relationship with games and a game has a has\_and\_belongs\_to\_many relationship with players and external\_players ? Well ActiveRecord let's use these associations so that we can get all of the players and external players associated to our user via games. That's a lot to the think about so I'll just dive straight into the code. In `app/models/users/rb` add the two new associations `has_many :players, :through => :games, :uniq => true` and `has_many :external_players, :through => :games, :uniq => true` 

~~~ruby
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :password, :password_confirmation, :remember_me
  # attr_accessible :title, :body
  
  has_and_belongs_to_many :sports
  has_and_belongs_to_many :games
  
  has_many :players, :through => :games, :uniq => true
  has_many :external_players, :through => :games, :uniq => true
  
  has_many :owned_games, :class_name => 'Game', :foreign_key => :owner_id
end
~~~

Let's try this in console. 

~~~console
rails c

> user = User.first

> user.players

SELECT DISTINCT "users".* FROM "users" INNER JOIN "games_users" ON "users"."id" = "games_users"."user_id" INNER JOIN "games" ON "games_users"."game_id" = "games"."id" INNER JOIN "games_users" "games_players_join" ON "games"."id" = "games_players_join"."game_id" WHERE "games_players_join"."user_id" = 1
~~~

Active record has joined `users` to `games\_users` to `games` and self-joined back to `games_users` to get us all the players our user has been associated with in a game. It self-joined because a player is a user.

~~~console
> user.external_players
SELECT DISTINCT "external_players".* FROM "external_players" INNER JOIN "external_players_games" ON "external_players"."id" = "external_players_games"."external_player_id" INNER JOIN "games" ON "external_players_games"."game_id" = "games"."id" INNER JOIN "games_users" ON "games"."id" = "games_users"."game_id" WHERE "games_users"."user_id" = 1
~~~

Active record has joined `external_players` to `external_players_games` to `games` to `games_users` to get us all the external users our signed-in user is associated with via a game.

Glad I didn't have to do that by hand.

### it 'should display a list of check_boxes for the current users players in table#players with only the current user selected'
We want this test to ensure that we display a list of all the `user.players` associated with the signed-in user through games. Our signed-in user will be in this list and we want that user to be checked by default while all of the others are unchecked by default.

1. Create four players
1. Create three games
1. Add the current user to the first two games.
1. Add players 1, 3 & 4 to the first two games so they are associated with our signed-in user.
1. Add player2 to game3 so that it has no connection with our signed-in user.
1. Visit the index page and create a new game
1. Ensure that we have a checked checkbox for the signed-in user in the `"div#players"` control group.
1. Ensure that we have an unchecked checkbox for players 1, 3, 4 in the `"div#players"` control group.
1. Ensure that we don't have a checkbox for player2 in the `"div#players"` control group.


~~~ruby
it 'should display a list of check_boxes for the current users players in table#players with only the current user selected' do

   player1 = FactoryGirl.create(:user)
   player2 = FactoryGirl.create(:user)
   player3 = FactoryGirl.create(:user)
   player4 = FactoryGirl.create(:user)

   game1 = FactoryGirl.create(:game, :owner => @user)
   game2 = FactoryGirl.create(:game, :owner => player2)
   game3 = FactoryGirl.create(:game, :owner => FactoryGirl.create(:user))

   game1.players << @user
   game2.players << @user

   game1.players << player1
   game2.players << player3
   game2.players << player4
   
   game3.players << player2 #a game created by a different user and player

   visit games_path

   click_link('Create Game')

   within("div#players") do
     page.has_field?("game_player_id_#{@user.id}").should be_true
     page.find("input#game_player_id_#{@user.id}").should be_checked

     page.has_field?("game_player_id_#{player1.id}").should be_true
     page.find("input#game_player_id_#{player1.id}").should_not be_checked

     page.has_field?("game_player_id_#{player3.id}").should be_true
     page.find("input#game_player_id_#{player3.id}").should_not be_checked

     page.has_field?("game_player_id_#{player4.id}").should be_true
     page.find("input#game_player_id_#{player4.id}").should_not be_checked

     page.has_field?("game_player_id_#{player2.id}").should be_false
   end


end
~~~

Let's add a control group that iterates through the signed-in user's players collection and creates a checkbox for each one.

~~~ruby
<div class="control-group <%= "error" if @game.errors.any? %>">
    <%= label_tag :players, nil, :class => 'control-label' %>
    <div class='controls' id="players">
		<% current_user.players.each do |player| %>
		 <%= check_box_tag "game[player_ids][]", player.id, @game.players.include?(player), :id => "game_player_id_#{player.id}" %> <%= player.email %><br/>
	    <% end %>
    </div>
</div>
~~~

`<%= check_box_tag "game[player_ids][]", player.id, @game.players.include?(player), :id => "game_player_id_#{player.id}" %>` will produce html like `<input id="game_player_id_1" name="game[player_ids][]" type="checkbox" value="1">` and we ensure the existance and checked-state for these in our tests above e.g.:

~~~ruby
page.has_field?("game_player_id_#{player4.id}").should be_true
page.find("input#game_player_id_#{player4.id}").should_not be_checked
~~~

The test should now pass:

~~~console
bundle exec rake spec
~~~

### it 'should display a list of check_boxes for the current users external\_players in table#players all unchecked'
We want this test to ensure that we display a list of all the `user.external_players` associated with the signed-in user through games. They should all be unchecked.

1. We create four players. 
1. We create three games.
1. We add our sign-in user and players 1, 3 and 4 to games so that they are associated with each other
1. We add player2 to a game owned by another user so player 2 won't be associated with the signed-in user.
1. We visit the index page, click 'Create Game' and make sure that we have an unchecked checkbox for players 1, 3 and 4 in the `div#external_players` control-group. 
1. We make sure we don't have player 2 in the `div#external_players` control group.

~~~ruby
it 'should display a list of check_boxes for the current users external\_players in table#players all unchecked' do

   player1 = FactoryGirl.create(:external_player)
   player2 = FactoryGirl.create(:external_player)
   player3 = FactoryGirl.create(:external_player)
   player4 = FactoryGirl.create(:external_player)

   game1 = FactoryGirl.create(:game, :owner => @user)
   game2 = FactoryGirl.create(:game, :owner => player4)
   game3 = FactoryGirl.create(:game, :owner => FactoryGirl.create(:user))

   game1.players << @user
   game2.players << @user

   game1.external_players << player1
   game2.external_players << player3
   game2.external_players << player4
   
   game3.external_players << player2

   visit games_path

   click_link('Create Game')

   within("div#external_players") do

     page.has_field?("game_external_player_id_#{player1.id}").should be_true
     page.find("input#game_external_player_id_#{player1.id}").should_not be_checked

     page.has_field?("game_external_player_id_#{player3.id}").should be_true
     page.find("input#game_external_player_id_#{player3.id}").should_not be_checked

     page.has_field?("game_external_player_id_#{player4.id}").should be_true
     page.find("input#game_external_player_id_#{player4.id}").should_not be_checked

     page.has_field?("game_external_player_id_#{player2.id}").should be_false
   end

end
~~~



Let's add a control group that iterates through the signed-in user's external_players collection and creates a checkbox for each one.

~~~ruby
<div class="control-group <%= "error" if @game.errors.any? %>">
    <%= label\_tag :players\_not\_on\_stinky\_trainers, nil, :class => 'control-label' %>
    <div class='controls' id="external_players">
  		<% current_user.external_players.each do |external_player| %>
			<%= check_box_tag "game[external_player_ids][]", external_player.id, @game.external_players.include?(external_player), :id => "game_external_player_id_#{external_player.id}" %> <%= external_player.email %><br/>
  		<% end %>
    </div>
</div>
~~~

The test should now pass

~~~console
bundle exec rake spec
~~~

### it 'should submit a list of the selected players and add them to the game'
When the form is submitted we want Rails to add all of the players that have been checked in the players list to be added to the `game.players` association.

1. Create 3 players
1. Create a game, add the three players and our signed-in user. This isn't the game in our form but one that's already created & ensures that they are associated with our signed-in user.
1. Visit the index page and click 'Create Game'
1. Fill in the game details making our location a Guid.
1. Uncheck our signed-in user from the list of players and select players 1 and 3
1. Submit the form
1. Find the game we just created using our unique Guid location.
1. Ensure that the `game.players =~ [player1, player3]` Note that =~ is an RSpec way of comparing two arrays whilst ignoring the order of that Array.

~~~ruby
it 'should submit a list of the selected players and add them to the game' do

	 sport = FactoryGirl.create(:sport)

	 player1 = FactoryGirl.create(:user)
	 player2 = FactoryGirl.create(:user)
	 player3 = FactoryGirl.create(:user)

	 game = FactoryGirl.create(:game, :owner => @user)

	 game.players << @user

	 game.players << player1
	 game.players << player2
	 game.players << player3

	 visit games_path

	 click_link('Create Game')

	 unique_location = SecureRandom.uuid

	 fill_in("Location", :with => unique_location)
	 select(sport.name, :from => "Sport")

	 time = Time.now + 3600 

	 select(time.year.to_s, :from => 'game[at(1i)]')
	 select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	 select(time.day.to_s, :from => 'game[at(3i)]')
	 select(time.hour.to_s, :from => 'game[at(4i)]')
	 select(time.min.to_s, :from => 'game[at(5i)]')

	 uncheck("game_player_id_#{@user.id}")
	 check("game_player_id_#{player1.id}")
	 check("game_player_id_#{player3.id}")

	 click_button('Create Game')

	 created_game = Game.find_by_location(unique_location)

	 created_game.players.should =~ [player1, player3]

end
~~~

ActiveRecord has built-in functionality for adding these list of players to our game so we don't have to do that much. When the form is submitted, the parameters for game are passed to the controller as below:

~~~console
"game"=>{"sport\_id"=>"8", "location"=>"wembley", "at(1i)"=>"2012", "at(2i)"=>"9", "at(3i)"=>"23", "at(4i)"=>"14", "at(5i)"=>"34", "player\_ids"=>["1","3","7"]}
~~~

ActiveRecord automatically sets the game's players as players with id 1, 3 and 7 and all our has to do is do what it's already doing `Game.new(params[:game])`. ActiveRecord is smart enough to understand that player_ids array is an array of ids for the players association.

There is one bit of code we must change to make all this work. We need to set our game class to accept the attributes player\_ids or we'll get a pesky `can't mass-assign attributes` error. Add the player\_ids assignment to `attr_accessible` in `app/models/game.rb`.

~~~ruby
class Game < ActiveRecord::Base
  attr\_accessible :at, :location, :sport, :owner, :sport\_id, :player\_ids

  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
  
  validate :cannot_create_a_game_in_the_past, :on => :create
   
  def over?
    Time.now > self.at
  end
  
  private
  
  def cannot_create_a_game_in_the_past
    return unless self.at
    self.errors.add(:at, 'Cannot create a game in the past') if self.over?
  end
  
end
~~~

### it 'should submit a list of the selected external players and add them to the game'
When the form is submitted we want Rails to add all of the players that have been checked in the players list to be added to the `game.external_players` association.

1. Create 3 external players
1. Create a game, add the three players and our signed-in user. Again, this isn't the game in our form but one that's already created to ensure that the external players are associated with our signed-in user.
1. Visit the index page and click 'Create Game'
1. Fill in the game details making our location a Guid.
1. Select external players 1 and 3 
1. Submit the form
1. Find the game we just created using our unique Guid location.
1. Ensure that the `game.players =~ [player1, player3]` Note that =~ is an RSpec way of comparing two arrays whilst ignoring the order of that Array. 

~~~ruby
it 'should submit a list of the selected external players and add them to the game' do

	sport = FactoryGirl.create(:sport)

	player1 = FactoryGirl.create(:external_player)
	player2 = FactoryGirl.create(:external_player)
	player3 = FactoryGirl.create(:external_player)

	game = FactoryGirl.create(:game, :owner => @user)

	game.players << @user

	game.external_players << player1
	game.external_players << player2
	game.external_players << player3

	visit games_path

	click_link('Create Game')

	unique_location = SecureRandom.uuid

	fill_in("Location", :with => unique_location)
	select(sport.name, :from => "Sport")

	time = Time.now + 3600 

	select(time.year.to_s, :from => 'game[at(1i)]')
	select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	select(time.day.to_s, :from => 'game[at(3i)]')
	select(time.hour.to_s, :from => 'game[at(4i)]')
	select(time.min.to_s, :from => 'game[at(5i)]')


	check("game_external_player_id_#{player1.id}")
	check("game_external_player_id_#{player3.id}")

	click_button('Create Game')

	created_game = Game.find_by_location(unique_location)

	created_game.external_players.should =~ [player1, player3]

end
~~~

This is very similar to adding players above. Again ActiveRecord has built-in functionality for adding these list of players to our game so we don't have to do that much. When the form is submitted, the parameters for game are passed to the controller as below:

~~~console
"game"=>{"sport\_id"=>"8", "location"=>"wembley", "at(1i)"=>"2012", "at(2i)"=>"9", "at(3i)"=>"23", "at(4i)"=>"14", "at(5i)"=>"34", "external_player\_ids"=>["1","3"]}
~~~

ActiveRecord automatically sets the game's players as players with id 1 & 3 and all our has to do is do what it's already doing `Game.new(params[:game])`. ActiveRecord is smart enough to understand that external\_player\_ids array is an array of ids for the players association.

Again there is one bit of code we must change to make all this work. We need to set our game class to accept the attributes external\_player\_ids or we'll get the `can't mass-assign attributes` error. Add the external\_player\_ids assignment to `attr_accessible` in `app/models/game.rb`.

~~~ruby
class Game < ActiveRecord::Base
  attr_accessible :at, :location, :sport, :owner, :sport_id, :player_ids, :external_player_ids

  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
  
  validate :cannot_create_a_game_in_the_past, :on => :create
   
  def over?
    Time.now > self.at
  end
  
  private
  
  def cannot_create_a_game_in_the_past
    return unless self.at
    self.errors.add(:at, 'Cannot create a game in the past') if self.over?
  end
  
end
~~~


### Adding a new player

Lastly we need to be able to add a new player that we haven't played with before. We'll just add a textfield where the user can add an email address. When the form is submitted then we use the email to find an existing player (User) or an existing external\_player. If we don't find either then we create a new external player and add it to the game. 

Let's write some draft tests:

~~~ruby
it 'should add a player where the email matches an existing user'
it 'should add an external player where the email doesn't match an existing user but matches an existing External Player
it 'should create and add an external player where the email doesn't match an existing user or external player' 
~~~

Before we start with our integration tests, there's a little bit of business logic going on here and I don't want to put it into our controller so we;re going to go back and add a method to the Game class `add_new_player` that accepts an email as an argument then looks for a User with that email, an External Player with that email or otherwise creates an ExternalPlayer.

Let's write some tests in `spec/models/game_spec.rb`

ruby~~~
it 'should add a user to players if a user with the email exists'
it 'should add an external player to external players if an external player with the email exists'
it 'should create an external player and add it to external players if no user or external player exists'
~~~

#### it 'should add a user to players if a user with the email exists'
Let's write a test for our game model that:

1. creates a game
1. creates a user
1. calls `add_new_player` on game with the email of the user we created
1. checks that the user has been added to game.

~~~ruby
it 'should add a user to players if a user with the email exists' do
  player = FactoryGirl.create(:user)
  game = FactoryGirl.create(:game)
  game.add\_new\_player(player.email)
  game.players.should == [player]
end
~~~

To get the test passing we need to code the game.add\_new\_player(email) method. In our `models/game.rb` class add this code:

~~~ruby
def add\_new\_player(email)

	if (player = User.find_by_email(email))
	  players << player
	  return
	end
	
end
~~~

the test should now pass

~~~ruby
bundle exec rake spec
~~~

#### it 'should add a user to players if a user with the email exists'
This test is similar to our previous one.

1. creates a game
1. creates an external player
1. calls `add_new_player` on game with the email of the external player we created
1. checks that the external has been added to game.


it 'should add a user to players if a user with the email exists' do
  external_player = FactoryGirl.create(:external_player)
  game = FactoryGirl.create(:game)
  game.add_new_player(external_player.email)
  game.external_players.should == [external_player]
end

To get the test passing we need to extend the code in game.add\_new\_player(email). Add the `if (player = ExternalPlayer.find_by_email(email))` code block to `app/models/game.rb`

~~~ruby
def add\_new\_player(email)

	if (player = User.find_by_email(email))
	  players << player
	  return
	end
	
	if (player = ExternalPlayer.find_by_email(email))
      external_players << player
      return
    end
	
end
~~~

the test should now pass

~~~ruby
bundle exec rake spec
~~~



#### it 'should create an external player and add it to external players if no user or external player exists'
This test expects us to create and add an external player when we provide an email that doesn't exists.

1. Create a game
1. Call `game.add_new_player` with an email that doesn't exist as a user or external player. We won't create any users or external players so it's safe to assume this email doesn't exists.
1. Wrap the call to `game.add_new_player` in a block that expects us to increase the number of external players by 1.
1. Find the newly created external player and ensure that the game has this player in its external players collection.

~~~ruby
it 'should create an external player and add it to external players if no user or external player exists' do
    game = FactoryGirl.create(:game)

    expect{
     game.add_new_player('test@testxyz.co.xy')
    }.to change{ExternalPlayer.count}.by(1)

    external_player = ExternalPlayer.find_by_email('test@testxyz.co.xy')
    game.external_players.should == [external_player]
end
~~~

To get the test passing we need to extend the code in game.add\_new\_player(email) once again. Add the line `external_players.create!(:email => email)` to `app/models/game.rb`

~~~ruby
def add\_new\_player(email)

	if (player = User.find_by_email(email))
	  players << player
	  return
	end
	
	if (player = ExternalPlayer.find_by_email(email))
      external_players << player
      return
    end

    external_players.create!(:email => email)
	
end
~~~

the test should now pass

~~~ruby
bundle exec rake spec
~~~


### it 'should add a player where the email matches an existing user'
So that's the additional logic to our game model written and tested. Now we can return to our integration tests for the game controller. From above they were:

~~~ruby
 it 'should add a player where the email matches an existing user'
 it 'should add an external player where the email doesn't match an existing user but matches an existing External Player
 it 'should create and add an external player where the email doesn't match an existing user or external player' 
~~~

Hmmm, they look very similar to the three model tests we just wrote. Because we pushed the logic into the model and out of the controller, our controller tests are now just doing the same thing as our model tests. In each of these three integration tests our controller would be calling the same line of code `@game.add_new_player(email)`. So, I'm going to scrap these tests - which is good model tests are always more succinct than integration tests - and replace them by two simpler integration tests:

~~~ruby
it 'should call add\_new\_player' on creating a valid game when a new player email is provided'
it 'should not call add\_new\_player' on creating a valid game when no new player email is provided'  
it 'should not call add\_new\_player' on creating an invalid game when a new player email is not provided'
~~~

#### it 'should call add\_new\_player' on creating a valid game when a new player email is provided'
A slight confession before we write the three above tests. They're not integration tests, they're controller tests we said earlier that we weren't going to do. What makes it a controller test and not an integration test ? If you look at the the three draft tests above, they all require a method to be called (or not called) inside of the controller. Integration test generally emulate the user experience while controller & view tests define what the application is doing under the hood. We could, of course, write the draft integration tests we intially envisaged even though they pretty much shadow our model tests for `game.add_new_player` but we're here to learn and this is a good opportunity to do a little old-school controller testing.

If it doesn't exists, create a file spec/controllers/games_controller_spec.rb with the code

~~~ruby
require 'spec_helper'

describe GamesController do

end
~~~

Let's write a test for our games controller that makes sure add\_new\_player get's called for a valid game and when a new player email is provided.

1. We sign\_in a user 
1. We create an instance of game with FactoryGirl and set an expectation on that instance that add\_new\_player will be called once with the email address 'test@yxz.wx.yz' `game.should_receive(:add_new_player).with('test@yxz.wx.yz')`
1. We also stub our instance of game so that it returns true when we call `@game.save`. This simulates the game being valid and saves us providing lots of parameters we don't need. All we do is provide the arbitrary string 'game params'.
1. Then - and this isn't pretty - we have to stub Game.new so that it returns the instance of game we've already set expectations and stubs on; unlike model specs, all this code is running inside the controller, not our test so if we don't stub Game.new it will just create a new game instance inside the controller and our FactoryGirl instance will never be used.
1. Lastly we call `post create` to call the action on our controller passing it the new\_player and game params.


~~~ruby
require 'spec_helper'

describe GamesController do
  
  it 'should call add_new_player on creating a valid game when a new player email is provided' do
 	  
 	  sign_in :user, FactoryGirl.create(:user)
 	  
 	  game = FactoryGirl.create(:game)
 	  game.should_receive(:add_new_player).with('test@yxz.wx.yz')
      game.stub(:save).and_return(true)
 	  Game.stub(:new).with('game params').and_return(game)

 	  post 'create', :new_player => 'test@yxz.wx.yz', :game => 'game params'
 	  
  end

end
~~~

To get this test passing we need some code in our games controllers create method

~~~ruby
def create
	@game = Game.new(params[:game])
	@game.owner = current_user
	@game.add\_new\_player(params[:new\_player])
	if @game.save
		redirect\_to game\_path(@game)
	else
		render :template => 'games/new.html.erb'
	end
end
~~~ 

The test should now pass:

~~~console
bundle exec rake spec
~~~

#### it 'should not call add\_new\_player on creating a valid game when a 'new player' email is not provided'
This test is the opposite of our previous test and also a controller test except this time we don't provide the new\_player parameter and expect that add\_new\_player is never called - `game.should_receive(:add_new_player).with(anything).never`

1. We sign\_in a user 
1. We create an instance of game with FactoryGirl and set an expectation on that instance that add\_new\_player will never be called.
1. We also stub our instance of game so that it returns true when we call `@game.save`. This simulates the game being valid and saves us providing lots of parameters we don't need. All we do is provide the arbitrary string 'game params'.
1. Once again we have to stub Game.new so that it returns the instance of game we've already set expectations and stubs on; unlike model specs, all this code is running inside the controller, not our test so if we don't stub Game.new it will just create a new game instance inside the controller and our FactoryGirl instance will never be used.
1. Lastly we call `post create` but this time don't pass the new\_player params.


~~~ruby
it 'should not call add\_new\_player on creating a valid game when a new player email is not provided' do
  
	sign_in :user, FactoryGirl.create(:user)

	game = FactoryGirl.create(:game)
	game.stub(:save).and_return(true)
	game.should_receive(:add_new_player).with(anything).never
	Game.stub(:new).with('game params').and_return(game)

	post 'create', :game => 'game params'
	
end
~~~

to get this test working we have to add a condition `unless params[:new_player].blank?` to the line of code we added in the previous test in `app/controllers/games_controller.rb`

~~~ruby
def create
	@game = Game.new(params[:game])
	@game.owner = current_user
	@game.add_new_player(params[:new\_player]) unless params[:new_player].blank?
	if @game.save
		redirect_to game_path(@game)
	else
		render :template => 'games/new.html.erb'
	end
end
~~~  

The test should now pass:

~~~console
bundle exec rake spec
~~~

#### it 'should not call add\_new\_player on creating an invalid game even when a new player email is provided'
This is the last controller spec test for the time being. We don't want `game.add_new_player` to be called if the game isn't valid.

1. We sign\_in a user 
1. We create an instance of game with FactoryGirl and set an expectation on that instance that add\_new\_player will never be called.
1. We also stub our instance of game so that it returns false when we call `@game.save`. This simulates the game being invalid.
1. Once again we have to stub Game.new so that it returns the instance of game we've already set expectations and stubs on; unlike model specs, all this code is running inside the controller, not our test so if we don't stub Game.new it will just create a new game instance inside the controller and our FactoryGirl instance will never be used.
1. Lastly we call `post create` to call the action on our controller passing it the new\_player and game params.

Still in `spec/controllers/games_controller_spec.rb`

~~~ruby
it 'should not call add\_new\_player on creating an invalid game even when a new player email is provided' do
  
	sign_in :user, FactoryGirl.create(:user)

	game = FactoryGirl.create(:game)
	game.stub(:save).and_return(false)
	game.should_receive(:add_new_player).with('test@yxz.wx.yz').never
	Game.stub(:new).with('game params').and_return(game)

	post 'create', :new_player => 'test@yxz.wx.yz', :game => 'game params'
  
end
~~~

To get this test passing we just move our `add_new_player` code inside the `if @game.save` block so that it only gets called when the game is successfully saved. This brings us onto an interesting point about ActiveRecord associations. If the object has been saved to the database, the association gets created as soon as you add something to it. You don't have to call `game.save` again.

~~~ruby
def create
  @game = Game.new(params[:game])
  @game.owner = current_user

  if @game.save
    @game.add_new_player(params[:new_player]) unless params[:new_player].blank?
	redirect_to game_path(@game)
  else
	render :template => 'games/new.html.erb'
  end
end
~~~
 
The test should now pass:

~~~console
bundle exec rake spec
~~~

That'll be the end of our controller specs for the time being. They served a purpose - and sometimes you just can't live without them - but I'm pretty sure you'll agree that they don't feel quite as relevant as integration test. 

## Testing the edit/updates actions

## Testing the show action

## Testing the destroy action