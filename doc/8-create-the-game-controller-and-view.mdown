# The Game Controller and View
We want to be able to carry out the full RESTful actions on game:

1. List - the index action
2. Create - the new > create actions
3. Edit - the edit > update actions
4. Show - the show action
5. Destroy - the destroy action

So we're going to generate the controller, set the controller up as a RESTful resource in our routes, write the functional tests then make them all pass.

## Generate the controller
We'll tell the generator to all of the RESTful actions for us.

~~~console
rails generate controller games index new create update edit show destroy

create  app/controllers/games_controller.rb
      route  get "games/destroy"
      route  get "games/show"
      route  get "games/edit"
      route  get "games/update"
      route  get "games/create"
      route  get "games/new"
      route  get "games/index"
     invoke  erb
     create    app/views/games
     create    app/views/games/index.html.erb
     create    app/views/games/new.html.erb
     create    app/views/games/create.html.erb
     create    app/views/games/update.html.erb
     create    app/views/games/edit.html.erb
     create    app/views/games/show.html.erb
     create    app/views/games/destroy.html.erb
     invoke  rspec
     create    spec/controllers/games_controller_spec.rb
     create    spec/views/games
     create    spec/views/games/index.html.erb_spec.rb
     create    spec/views/games/new.html.erb_spec.rb
     create    spec/views/games/create.html.erb_spec.rb
     create    spec/views/games/update.html.erb_spec.rb
     create    spec/views/games/edit.html.erb_spec.rb
     create    spec/views/games/show.html.erb_spec.rb
     create    spec/views/games/destroy.html.erb_spec.rb
     invoke  helper
     create    app/helpers/games_helper.rb
     invoke    rspec
     create      spec/helpers/games_helper_spec.rb
     invoke  assets
     invoke    coffee
     create      app/assets/javascripts/games.js.coffee
     invoke    scss
     create      app/assets/stylesheets/games.css.scss
~~~

Let's create games as a RESTful resource in `config/routes.rb` by removing:

~~~ruby
get "games/index"

get "games/new"

get "games/create"

get "games/update"

get "games/edit"

get "games/show"

get "games/destroy"
~~~

and creating games as a resource. Since we're using all of the RESTful actions then we don't need to limit it with `:only =>[]` 

~~~ruby
Stinkytrainers::Application.routes.draw do
  
  
  devise_for :users

  resources :sports, :only => [:index, :new, :create, :destroy]

  resources :dashboard, :only => [:index] 
  
  resources :games

  root :to => 'home#index'

end
~~~

Take a look at the routes we've created

~~~console 
bundle exec rake routes

 new_user_session GET    /users/sign_in(.:format)                  devise/sessions#new
            user_session POST   /users/sign_in(.:format)                  devise/sessions#create
    destroy_user_session DELETE /users/sign_out(.:format)                 devise/sessions#destroy
           user_password POST   /users/password(.:format)                 devise/passwords#create
       new_user_password GET    /users/password/new(.:format)             devise/passwords#new
      edit_user_password GET    /users/password/edit(.:format)            devise/passwords#edit
                         PUT    /users/password(.:format)                 devise/passwords#update
cancel_user_registration GET    /users/cancel(.:format)                   devise/registrations#cancel
       user_registration POST   /users(.:format)                          devise/registrations#create
   new_user_registration GET    /users/sign_up(.:format)                  devise/registrations#new
  edit_user_registration GET    /users/edit(.:format)                     devise/registrations#edit
                         PUT    /users(.:format)                          devise/registrations#update
                         DELETE /users(.:format)                          devise/registrations#destroy
                  sports GET    /sports(.:format)                         sports#index
                         POST   /sports(.:format)                         sports#create
               new_sport GET    /sports/new(.:format)                     sports#new
                   sport DELETE /sports/:id(.:format)                     sports#destroy
         dashboard_index GET    /dashboard(.:format)                      dashboard#index
                   games GET    /games(.:format)                          games#index
                         POST   /games(.:format)                          games#create
                new_game GET    /games/new(.:format)                      games#new
               edit_game GET    /games/:id/edit(.:format)                 games#edit
                    game GET    /games/:id(.:format)                      games#show
                         PUT    /games/:id(.:format)                      games#update
                         DELETE /games/:id(.:format)                      games#destroy
                    root        /                                         home#index
~~~

You can see we now have games routes matching each of our actions. As a quick reminder of RESTful routes let's review the routes we've created. I've assumed we already have a game with the id 179:

<table>
	<tr>
		<th>url</th>
		<th>action</th>
	</tr>
	<tr>
		<td>GET /games</td>
		<td>games#index</td>
	</tr>
	<tr>
		<td>POST /games</td>
		<td>games#create</td>
	</tr>
	<tr>
		<td>GET /games/new</td>
		<td>games#new</td>
	</tr>
	<tr>
		<td>GET /games/179/edit</td>
		<td>games#edit with params[:id] = 179</td>
	</tr>
	<tr>
		<td>GET /games/179</td>
		<td>games#show with params[:id] = 179</td>
	</tr>
	<tr>
		<td>PUT /games/179</td>
		<td>games#update with params[:id] = 179</td>
	</tr>
	<tr>
		<td>DELETE /games/179</td>
		<td>games#destroy with params[:id] = 179</td>
	</tr>
</table>

## Our draft functional tests for the games controller
I'm going to introduce the concept of describe blocks in testing here. They let us group our tests together and each block can have its own setup and teardown code. Don't worry if you're not sure what setup and teardown means all will become apparent.

Before we write our draft tests we must delete the file `spec/constrollers/games_controller_spec.rb` since we're testing views and controllers together as integration tests.

Create the file spec/integration/games/resftful_spec.rb and add the empty draft tests below: 

~~~ruby
require 'spec_helper'

describe 'games' do
  
  describe 'authentication' do
    it 'should redirect users to the sign-in page when they are not signed-in'
  end

  describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user'
    it 'should display a list of the games where the signed-in user is a player'
  end

  describe 'creating games' do
    it 'should create a new game when valid game parameters are provided'
    it 'should redirect users back to the new page with user input when incorrect parameters are provided'
  end


  describe 'editing games' do
    it 'should edit a game and update it when the values are valid'
    it 'should edit a game and return then to the edit page with their edited input when incorrect parameters are provided'
  end

  describe 'showing games' do
    it 'should allow users to view a game'
  end

  describe 'destroying games' do
    it 'should allow users to destroy a game and redirect them back to the index page'
  end
  
end
~~~

## Testing authentication
The test we need to pass is `it 'should redirect users to the sign-in page when they are not signed-in'`

This is very similar to our previous authentication tests. Create the file `spec/integration/games/authentication_spoec.rb` and add this code:

~~~ruby
require 'spec_helper'

describe 'authentication' do
  it 'should require users to sign in when they trying to access sports' do
    user = FactoryGirl.create(:user)

    visit games_path

    page.current_path.should == new_user_session_path

    fill_in('Email', :with => user.email)
    fill_in('Password', :with => user.password)

    click_button('Sign in')

    page.current_path.should == games_path
  end
end
~~~

Run the tests:

~~~ruby
bundle exec rake spec
~~~

You should see one failure because we haven't secured the games_controller yet. So we'll do that now by adding the Devise `authenticate_user!`

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
  end

  def new
  end

  def create
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

Run the tests again and it should all pass

~~~ruby
bundle exec rake spec
~~~

## Testing the index action
Our previous sports controller index action was quite simple, all we wanted to do is list all sports. This one is a little more difficult as we want to list two things:

ruby~~~
describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user'
    it 'should display a list of the games where the signed-in user is a player'
end
~~~

### Make our games Factory more useful

Before we start writing tests, Games require owners and sports so our integration tests are going to be using FactoryGirl to create these objects quite frequently.

Our current games factory `spec/factories/games.rb` looks something like this

~~~ruby
FactoryGirl.define do
  factory :game do
    location "MyString"
    at "2012-09-09 10:00:00"
    sport { FactoryGirl.create(:sport) }
    owner { FactoryGirl.create(:user) }
  end
end
~~~ 

So in our tests the :location and :at fields always have the same values which isn't really realistic or helpful. Update it so that, like email in the user factory and name in the sport factory, locations and times are always different. 

~~~ruby
FactoryGirl.define do
  factory :game do
    location { generate(:location) } 
    at { generate(:at) }
    sport { FactoryGirl.create(:sport) }
    owner { FactoryGirl.create(:user) }          
  end
  
  sequence :location do |n|
    "location#{n}"
  end

  sequence :at do |n|
    Time.now + (n * 3600 * 24)
  end
end
~~~ 

### it 'should display a list of the games owned by the signed-in user'

So now let's code the first of our two tests.

First let's create a before(:each) block inside the `describe games` block. This will run before each test giving us a signed-in user `@user` so we don't have to keep writing the same login code over and over again. Again because we assign user to the instance variable `@user` and not just `user` it's available throughout the test. 

Write a test to: 

1. Create our signed-in user
1. Create another user that isn't the signed-in user
1. Create three games, two owned by the signed-in user and one owned by the user not signed-in
1. Ensure that the games we added to the user appears in the 'owned\_games' table on index page
1. Ensure that the game we didn't add to the signed-in user **doesn't appear** in the 'owned\_games' table on  the index page

Note that we check for the existence of the games inside these within blocks

~~~ruby
within("table#owned_games") do
  within("tr[@data-row='game_#{game1.id}']") do
  end
end
~~~

Which basically means the test is more than requiring the games to appear on the page, it's requiring the games to appear within a table with id my\_games and a table row with the data-row attribute data-row='game_x' where x is the id of the game in that row.

We could also have used more specific XPath and css attributes to specify where the games appear but then we'd have to keep fixing our tests each time the page design was altered. This approach feels like a reasonably pragmatic balance between not caring where the games appear and being very specific.

~~~ruby  
require 'spec_helper'

describe 'games' do
  
  before :each do
    @user = FactoryGirl.create(:user)
	  
	visit new_user_session_path
	  
	fill_in('Email', :with => @user.email)
    fill_in('Password', :with => @user.password)

    click_button('Sign in')
  end
  
  
  describe 'listing games' do
    it 'should display a list of the games owned by the signed-in user' do
        
    	other_user = FactoryGirl.create(:user)

	    game1 = FactoryGirl.create(:game, :owner => @user)
	    game2 = FactoryGirl.create(:game, :owner => @user)
	    game3 = FactoryGirl.create(:game, :owner => other_user)
    
	    visit games_path
  
	    within("table#owned_games") do
      
	      @user.owned_games.each do |game|
	        within("tr[@data-row='game_#{game.id}']") do
	          page.should have_content(game.location)
	          page.should have_content(game.sport.name)
	          page.should have_content(game.at)
	        end
	      end
      
	      other_user_game = other_user.owned_games.first
	      #page.save_and_show_page
	      page.should_not have_content(other_user_game.location)
	      page.should_not have_content(other_user_game.sport.name)
	      page.should_not have_content(other_user_game.at)
    
	    end
	
	end
	
	it 'should display a list of the games where the signed-in user is a player'
	
  end

  describe 'creating games' do
    it 'should create a new game when valid game parameters are provided with the current user selected as a player'
    it 'should redirect users back to the new page with user input when incorrect parameters are provided'
  end


  describe 'editing games' do
    it 'should edit a game and update it when the values are valid'
    it 'should edit a game and return then to the edit page with their edited input when incorrect parameters are provided'
  end

  describe 'showing games' do
    it 'should allow users to view a game'
  end

  describe 'destroying games' do
    it 'should allow users to destroy a game and redirect them back to the index page'
  end
  
end
~~~

run the tests...

~~~console
bundle exec rake spec
~~~

and it should fail because we haven't coded the controller or the view we're testing.

Let's start with the games controller `app/controllers/games_controller.rb`. It couldn't be simpler. In our previous sports controller we wanted all sports to be listed so we coded

~~~ruby
def index
  @sports = Sport.all
end
~~~

but now we want to list the games of the logged-in user (we can be sure we have a logged-in user because our previous spec required that). All we need do assign the games of the current user to variable @games which is passed to our view. Note that only instance (or '@') variables get passed on to the view. Variables that aren't prefixed '@' are local to the method only. 

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
    @owned_games = current_user.owned_games
  end

  def new
  end

  def create
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

You can try running the tests but they should still fail as we haven't coded the view. Let's do that now:

in `app/views/games/index.html.erb`

~~~ruby
<h1>Games#index</h1>

<h2>Game I have created</h2>
<table id="owned_games">
	<% @owned_games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>
~~~

Note that we use the `@owned_games` variable from our controller and insert the game id into the data-row attribute of the table.

Our test should now pass:

~~~console
bundle exec rake spec
~~~

### it 'should display a list of the games where the signed-in user is a player'
Now let's add the test that checks the list of games the signed-in user is playing in.

In this test we will

1. Create three games, two owned by the signed-in user and a third by another user
1. Add the signed-in user to one of the two games he/she created and add the signed-in user to the game created by the other user.
1. Test that the table "games" has the two games in which the signed-in user is a player - that's one of his games and one of the other user's games.
1. Test that the table "games" doesn't have the game in which the signed-in user isn't a player even though that's a game he created.

Add this code to the second of our two index page tests:

~~~ruby
it 'should display a list of the games the signed-in user is playing in' do

	game1 = FactoryGirl.create(:game, :owner => @user)
	game2 = FactoryGirl.create(:game, :owner => @user)
	game3 = FactoryGirl.create(:game, :owner => FactoryGirl.create(:user))
  
	game1.players << @user
	game3.players << @user

	visit games_path

	within("table#games") do
   
	  within("tr[@data-row='game_#{game1.id}']") do
	    page.should have_content(game1.location)
	    page.should have_content(game1.sport.name)
	    page.should have_content(game1.at)
	  end
  
	  within("tr[@data-row='game_#{game3.id}']") do
	    page.should have_content(game3.location)
	    page.should have_content(game3.sport.name)
	    page.should have_content(game3.at)
	  end
  
	  game_user_created = @user.games.last
  
	  page.save_and_open_page
  
	  page.should_not have_content(game2.location)
	  page.should_not have_content(game2.sport.name)
	  page.should_not have_content(game2.at)

	end
	
end
~~~

Run the tests to see it failing (remember we haven't coded the controller or view yet)

~~~console
bundle exec rake spec


1) games listing games should display a list of the games the signed-in user is playing in
    Failure/Error: within("table#games") do
    Capybara::ElementNotFound:
      Unable to find css "table#games"
    # (eval):2:in `find'
    # ./spec/integration/games/restful_spec.rb:57:in `block (3 levels) in <top (required)>'
	
~~~

Let's add a variable to our `app/controllers/games\_controller.rb` index action to reference the games our signed-in user is playing in.

~~~ruby
def index
 @owned_games = current_user.owned_games
 @games = current_user.games
end
~~~

and add the games table to the view app/views/games/index.html.erb

~~~ruby
<h1>Games#index</h1>

<h2>Games I have created</h2>
<table id="owned_games">
	<% @owned_games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>

<h2>Games I am playing</h2>
<table id="games">
	<% @games.each do |game| %>
	<tr data-row='game_<%= game.id %>'>
		<td><%= game.sport.name %></td>
		<td><%= game.location %></td>
		<td><%= game.at %></td>
	</tr>
	<% end %>
</table>
~~~

The tests should now pass.

## Creating Games
If a user provides the correct information to create a new game we want to redirect them to the game's 'show' page but if the information provided is invalid we return them to the 'new' page where they can correct the information.

~~~ruby
describe 'creating games' do
    it 'should create a new game when valid game parameters are provided and redirect'
    it 'should return users back to the new page with user input when incorrect parameters are provided'
end
~~~

### it 'should create a new game when valid game parameters are provided and redirect to the show page'
To do this the spec must

1. Journey to the new page by clicking a 'Create Game' link from the index page.
1. Select a sport for our game from a drop-down.
1. Complete a text box for `game.location`
1. Complete a rails **date_time_select** for `game.at`

A Rails date time select is a helper method that provides us with 5 drops down selects for year, month, day, hour and minute. In our case the selects for our `game.at` attribute will be called:

game[at(1i)]
game[at(2i)]
game[at(3i)]
game[at(4i)]
game[at(5i)]

ActiveRecord will automagically reassemble these five components back into a time for us.

~~~ruby
it 'should create a new game when valid game parameters are provided and redirect to the show page' do

	sport = FactoryGirl.create(:sport)

	visit games_path

	click_link('Create Game')

	fill_in("Location", :with => 'Wimbledon')
	select(sport.name, :from => "Sport")

	time = Time.now + 3600 #make it an hour from now

	select(time.year.to_s, :from => 'game[at(1i)]')
	select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	select(time.day.to_s, :from => 'game[at(3i)]')
	select(time.hour.to_s, :from => 'game[at(4i)]')
	select(time.min.to_s, :from => 'game[at(5i)]')

	expect{
	 click_button('Create Game')
	}.to change{Game.count}.by(1)

	page.current_path.should == game_path(Game.last)

end
~~~

I'm pretty certain that we'll be using the exact same form in 'edit' and 'new' so we'll create the form as a partial. Create the file `app/views/games/_form.html.erb` and include this in our 'new' view `app/views/games/hew.html.erb`. This will render `_form.html.erb` inside the view `new.html.erb`

~~~ruby
<h1>Games#new</h1>

<%= render 'form' %>
~~~

Let's code the form.

~~~ruby
<%= form_for @game do |f| %>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :sport_id, 'Sport', :class => 'control-label' %>
    <div class='controls'>
      <%= f.select :sport_id, options_from_collection_for_select(Sport.all, :id, :name), {:include_blank => true}, {:class => 'input-xlarge' } %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :location, :class => 'control-label' %>
    <div class='controls'>
      <%= f.text_field :location, :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :at, :class => 'control-label' %>
    <div class='controls'>
      <%= f.datetime_select "at",{}, :class => 'input-small' %>
    </div>
  </div>

  <div class="form-actions">
    <%= f.submit @game.new_record? ? 'Create Game' : 'Update Game', :class => 'btn btn-primary' %>
    <%= link_to 'Back', games_path, :class => 'btn' %>
  </div>

<% end %>
~~~

1. form\_for @game understands that this is a new record. @game.new\_record? == true because @game.id is nil. It creates a POST action rather than a PUT. When we get as far as editing an existing game then @game.new\_record? == false because a game being edited will have an id. In this case form_for will make it a RESTFUL PUT action.
1. `form_for @game do |f|` labels and controls are bound to @game via 'f' e.g. `<%= f.label :location, :class => 'control-label' %>  <%= f.text_field :location, :class => 'input-xlarge' %>`. The :class arguments are simply TwitterBootstrap class names we want to appear in the html.
1. We've bound the :sport_id to the select box 'Sport' so that the parameter game[sport\_id] is submitted. If we'd left it as sport then game[sport]=1 would imply we had a sport that was the number 1 and not a sport object with an id that is 1. 
1. `options_from_collection_for_select(Sport.all, :id, :name)` builds the select drop-down with an option for each sport in `Sport.all` using the sport `sport.id` and `sport.name` as the option value and text. 

That's our form, let's code the new and create action in `app/controllers/games_controller.rb`.

~~~ruby
def new
	@game = Game.new
end

def create
  game = Game.new(params[:game])
  game.owner = current_user
  game.save
  redirect_to game\_path(game)
end
~~~

In `def new` we instantiate an empty game object so that it can be bound to the controls in our _form.html.erb partial. 

In `def create` we instantiate an empty object passing it params[:game]. Params[:game] is a hash containing all of the values submitted by our form that have game[:location], game[:sport_id]. A typical params hash is `{"utf8"=>"✓", "game"=>{"sport_id"=>"1", "location"=>"Wimbledon", "at(1i)"=>"2012", "at(2i)"=>"9", "at(3i)"=>"22", "at(4i)"=>"16", "at(5i)"=>"15"}, "more_players"=>"email", "commit"=>"Create Game", "action"=>"create", "controller"=>"games"}`. Note the keys and values in the `"game" =>` part of the hash.

A game needs an owner and that will always be the current user in our system so we set it.

We save the game and then redirect to the 'show' page for that game. Save would have populated the `game.id` from the database so game\_path(game) would be /games/123 for a game with id 123.

One last thing and this is a little ugly. Remember our form's sport control is bound to :sport\_id and not :sport ? Well, when we come to create our game in the controller it will be updating :sport\_id => 1 which means we have to make :sport\_id attr_accessible as well as sport. If we don't we're going to get one of those `Can't mass-assign protected attributes: sport_id` errors when we save.

~~~ruby
class Game < ActiveRecord::Base
  attr_accessible :at, :location, :sport, :owner, :sport\_id
  
  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
   
  def over?
    Time.now > self.at
  end
  
end
~~~

Let's run the tests, with our form and controller in place they should be passing:

~~~
bundle exec rake spec
~~~

### it 'should return users back to the new page with user input when incorrect parameters are provided'
This is similar to our previous test but, of course, we do something wrong so that when we submit our form the game is invalid. Let's submit a game that's in the past. We already have a helper method `game.over?` that we know will return true if the game is in the past so let's include that in a validation but ONLY if we're trying to create a new game NOT if we're trying to update something on an existing game.

We will add our own validation method to game. Before we do we'd better go back to our spec/models/game\_spec.rb and write a couple of additional tests for this validation. In `spec/models/game_spec.rb` add the two tests

~~~ruby
it 'should not be valid if the game has not been saved and is in the past' do
  game = Game.new(:at => Time.now - 1000)
  game.stub(:new\_record?).and_return(true)
  game.valid?
  game.errors.get(:at).should include("Cannot create a game in the past")
end

it 'should be valid if the game has been saved and is in the past' do
  game = Game.new(:at => Time.now - 1000)
  game.stub(:new\_record?).and_return(false)
  game.valid?
  game.errors.get(:at).should_not include("Cannot create a game in the past")
end
~~~

run the tests and see the first test fail.

~~~console
bundle exec rake spec
~~~

Note `game.stub(:new\_record?).and_return(false)`. Rather than manipulate test game ids so that we get new_record? to return the expected value we simply stub it out so that, for this one test, the game model returns the exact method we're looking for.

Let's create the validation in `models/game.rb`.

~~~ruby
class Game < ActiveRecord::Base
  attr_accessible :at, :location, :sport, :owner, :sport_id
  
  validates :location, :presence => true
  validates :at, :presence => true
  validates :sport, :presence => true
  validates :owner, :presence => true
  
  has_and_belongs_to_many :players, :class_name => 'User', :order => "users.email ASC"
  has_and_belongs_to_many :external_players, :order => "external_players.email ASC"
  belongs_to :sport
  belongs_to :owner, :class_name => 'User'
  
  validate :cannot_create_a_game_in_the_past, :on => :create
 
  def over?
    Time.now > self.at
  end
  
  private
  
  def cannot_create_a_game_in_the_past
    return unless self.at
    self.errors.add(:at, 'Cannot create a game in the past') if self.over?
  end
  
end

~~~

We create a private method that checks to see if the game is in the past and call it with `validate :cannot_create_a_game_in_the_past, :on => :create`. The `:on => create` option means that the validation only runs when the object is new - in other words when `game.new_record?` is true. If it is in the past we add the desired error message against our :at attribute. So how do we make sure that the test object returns the desired true or false for `game.new_record?`. We could, for example, create an object, save it with the time at now then wait a few seconds to be sure it'sin the past but that's clumsy. Instead we `game.stub(:new\_record?).and_return(false)` or true. Stub overrides the method `game.new_record?` for that one tests and returns true or false depending on what we specify in `.and_return`. It's simple and explicit.

Now we know that we can't create a game in the past let's try and do that to make sure our form returns us back to the new page with the bad data we've entered.

~~~ruby
it 'should redirect users back to the new page with user input when incorrect parameters are provided' do

	sport = FactoryGirl.create(:sport)

	visit games_path

	click_link('Create Game')

	fill_in("Location", :with => 'Wimbledon')
	select(sport.name, :from => "Sport")

	time = Time.now - 3600 #make it an hour in the past

	select(time.year.to_s, :from => 'game[at(1i)]')
	select(Date::MONTHNAMES[time.month], :from => 'game[at(2i)]')
	select(time.day.to_s, :from => 'game[at(3i)]')
	select(time.hour.to_s, :from => 'game[at(4i)]')
	select(time.min.to_s, :from => 'game[at(5i)]')

	expect{
	 click_button('Create Game')
	}.to change{Game.count}.by(0)

	page.find_field('Location').value.should have_content('Wimbledon')
	page.find_field('Sport').text.should have_content(sport.name)

	page.find_field('game[at(1i)]').value.should have_content(time.year.to_s)
	page.find_field('game[at(2i)]').text.should have_content(Date::MONTHNAMES[time.month])
	page.find_field('game[at(3i)]').value.should have_content(time.day.to_s)
	page.find_field('game[at(4i)]').value.should have_content(time.hour.to_s)
	page.find_field('game[at(5i)]').value.should have_content(time.min.to_s)
	
end
~~~

So we try to create a game in the past, check that Game.count doesn't change so our attempt to create a game has failed, then check that the rendered page has the `game.sport`, `game.at` and `game.location` data we submitted.

We need to code the controller so that it handles invalid requests so let's update `def create` in our `app/controllers/games_controller.rb` so that it looks like this:

~~~ruby
class GamesController < ApplicationController
  
  before_filter :authenticate_user!
  
  def index
    @owned_games = current_user.owned_games
    @games = current_user.games
  end

  def new
    @game = Game.new
    @game.players << current_user
  end

  def create
    @game = Game.new(params[:game])
    @game.owner = current_user
    if @game.save
  		redirect_to game_path(@game)
  	else
  		render :template => 'games/new.html.erb'
  	end
  end

  def update
  end

  def edit
  end

  def show
  end

  def destroy
  end
end
~~~

~~~console
bundle exec rake spec

Failures:

  1) games creating games should redirect users back to the new page with user input when incorrect parameters are provided
     Failure/Error: page.find_field('Sport').value.should have_content(sport.name)
       expected there to be content "sport7" in ""
     # ./spec/integration/games/restful_spec.rb:134:in `block (3 levels) in <top (required)>'
~~~

Just one problem, it fails. Our drop down for sport hasn't selected the sport we chose `expected there to be content "sport7" in ""` and has displayed the first option which is blank. We can fix this in the form by updating the `options_from_collection_for_select(Sport.all, :id, :name)` so that the form looks like

~~~ruby
<%= form_for @game do |f| %>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :sport_id, 'Sport', :class => 'control-label' %>
    <div class='controls'>
      <%= f.select :sport_id, options_from_collection_for_select(Sport.all, :id, :name, @game.sport.try(:id)), {:include_blank => true}, {:class => 'input-xlarge' } %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :location, :class => 'control-label' %>
    <div class='controls'>
      <%= f.text_field :location, :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :at, :class => 'control-label' %>
    <div class='controls'>
      <%= f.datetime_select "at",{}, :class => 'input-small' %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :players, :class => 'control-label' %>
    <div class='controls'>
  		<% current_user.players.each do |player| %>
			<%= check_box_tag :player, player.id, @game.players.include?(player) %> <%= player.email %><br/>
  		<% end %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :players_not_on_stinky_trainers, :class => 'control-label' %>
    <div class='controls'>
  		<% current_user.external_players.each do |player| %>
			<%= check_box_tag :external_player, player.id, @game.external_players.include?(player) %> <%= player.email %><br/>
  		<% end %>
    </div>
  </div>

  <div class="control-group <%= "error" if @game.errors.any? %>">
    <%= f.label :more_players, :class => 'control-label' %>
    <div class='controls'>
      <%= text_field_tag :more_players, 'email', :class => 'input-xlarge' %>
    </div>
  </div>

  <div class="form-actions">
    <%= f.submit @game.new_record? ? 'Create Game' : 'Update Game', :class => 'btn btn-primary' %>
    <%= link_to 'Back', games_path, :class => 'btn' %>
  </div>

<% end %>
~~~

We've added a third argument to option_from_collection_for_select @game.sport.try(:id). This third argument is the value we'd like the select box to choose as selected (if it exists) but why the `sport.try(:id)` and not just `sport.id` ? Well, on a completely new game in our first test above sport will actually be nil so calling id on nil will raise an error. With `sport.try(:id)` Rails will try to get the value id from sport but return nil, rather than an error, if something goes wrong.

But what about the players ? We haven't added any yet

## Testing the edit/updates actions

## Testing the show action

## Testing the destroy action